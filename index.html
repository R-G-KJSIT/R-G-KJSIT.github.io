<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>R Landing (You aren't meant to be here)</title>
    <style>
        :root {
            /* Default Theme: Cyberpunk */
            --bg-color: #050505;
            --grid-color: rgba(255, 255, 255, 0.05);
            --text-primary: #ff0055;
            --text-secondary: #00e5ff;
            --accent: #ffee00;
            --glass: rgba(20, 20, 20, 0.85);
            --border: 1px solid rgba(255, 255, 255, 0.1);
            --font-main: 'Courier New', Courier, monospace;
            --scanline: rgba(0,0,0,0.5);
        }

        [data-theme="matrix"] {
            --bg-color: #000000;
            --grid-color: rgba(0, 255, 0, 0.1);
            --text-primary: #00ff00;
            --text-secondary: #008f11;
            --accent: #ccffcc;
            --glass: rgba(0, 20, 0, 0.9);
            --border: 1px solid #00ff00;
            --font-main: 'Consolas', monospace;
        }

        [data-theme="vaporwave"] {
            --bg-color: #2b003b;
            --grid-color: rgba(255, 0, 255, 0.1);
            --text-primary: #ff71ce;
            --text-secondary: #01cdfe;
            --accent: #fffb96;
            --glass: rgba(255, 255, 255, 0.15);
            --border: 1px solid rgba(255, 113, 206, 0.5);
            --font-main: sans-serif;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            transition: all 0.2s ease;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            background-color: var(--bg-color);
            background-image: 
                linear-gradient(var(--grid-color) 1px, transparent 1px),
                linear-gradient(90deg, var(--grid-color) 1px, transparent 1px);
            background-size: 40px 40px;
            color: var(--text-primary);
            font-family: var(--font-main);
            height: 100vh;
            width: 100vw;
            overflow: hidden; /* Prevent scroll */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            touch-action: none; /* Disable browser gestures */
        }

        /* Scanline Overlay */
        body::after {
            content: " ";
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            bottom: 0;
            right: 0;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            z-index: 2;
            background-size: 100% 2px, 3px 100%;
            pointer-events: none;
        }

        /* Top Header Section */
        header {
            text-align: center;
            padding: 1.5rem 1rem 0.5rem;
            z-index: 10;
            width: 100%;
            max-width: 800px;
            flex-shrink: 0;
        }

        h1 {
            font-size: clamp(1.5rem, 5vw, 4rem);
            font-weight: 900;
            text-transform: uppercase;
            letter-spacing: -2px;
            color: var(--text-primary);
            text-shadow: 2px 2px 0px var(--text-secondary);
            margin-bottom: 0.2rem;
            animation: glitch 3s infinite;
        }

        p.subtitle {
            font-size: clamp(0.7rem, 2vw, 1rem);
            color: var(--text-secondary);
            opacity: 0.8;
            letter-spacing: 1px;
        }

        /* Theme Toggle */
        .theme-toggle {
            position: absolute;
            top: 20px;
            right: 20px;
            background: var(--glass);
            border: var(--border);
            color: var(--text-secondary);
            padding: 8px 16px;
            cursor: pointer;
            z-index: 100;
            font-family: inherit;
            font-weight: bold;
            backdrop-filter: blur(4px);
            font-size: 0.8rem;
        }

        .theme-toggle:hover {
            background: var(--text-secondary);
            color: var(--bg-color);
        }

        /* Game Container */
        .game-container {
            display: flex;
            gap: 20px;
            align-items: flex-start;
            justify-content: center;
            z-index: 10;
            padding-bottom: 1rem;
            flex-grow: 1;
            width: 100%;
            max-width: 600px;
        }

        .canvas-wrapper {
            position: relative;
            padding: 4px;
            background: var(--text-secondary);
            box-shadow: 0 0 20px var(--text-secondary);
            flex-shrink: 1;
        }

        canvas {
            display: block;
            background-color: #000;
            max-height: 60vh; /* Ensure it fits on mobile screens vertically */
            height: auto;
            width: auto;
            aspect-ratio: 240/400;
        }

        .sidebar {
            display: flex;
            flex-direction: column;
            gap: 15px;
            min-width: 120px;
        }

        .score-board {
            background: var(--glass);
            border: var(--border);
            padding: 15px;
            text-align: center;
            backdrop-filter: blur(5px);
        }

        .label {
            font-size: 0.8rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            margin-bottom: 5px;
        }

        .score {
            font-size: 1.5rem;
            color: var(--accent);
            font-weight: bold;
        }

        .controls-info {
            font-size: 0.8rem;
            color: var(--text-secondary);
            line-height: 1.5;
            background: var(--glass);
            padding: 10px;
            border: var(--border);
        }
        
        /* Mobile Controls */
        .mobile-controls {
            display: none;
            width: 100%;
            max-width: 500px;
            justify-content: space-between;
            padding: 0 20px 20px;
            position: fixed;
            bottom: 0;
            z-index: 100;
            pointer-events: none; /* Let clicks pass through container area */
        }

        .control-group {
            display: flex;
            gap: 12px;
            pointer-events: auto; /* Re-enable clicks for buttons */
        }

        .m-btn {
            background: var(--glass);
            border: var(--border);
            color: var(--text-secondary);
            width: 60px;
            height: 60px;
            font-size: 1.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 8px; /* Slightly rounded for tech feel */
            user-select: none;
            cursor: pointer;
            backdrop-filter: blur(8px);
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
            touch-action: none; /* Vital: prevents zoom/scroll on rapid tapping */
        }
        
        .m-btn:active {
            background: var(--text-secondary);
            color: var(--bg-color);
            transform: translateY(2px);
            box-shadow: 0 2px 5px rgba(0,0,0,0.5);
        }

        /* Highlight rotation button slightly */
        #btn-rotate {
            border-color: var(--accent);
            color: var(--accent);
        }
        #btn-rotate:active {
            background: var(--accent);
            color: var(--bg-color);
        }

        .game-over-overlay {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            display: none;
            z-index: 20;
            backdrop-filter: blur(2px);
        }

        .game-over-overlay.visible {
            display: flex;
        }

        .btn-restart {
            margin-top: 15px;
            padding: 12px 24px;
            font-family: inherit;
            background: var(--text-primary);
            border: none;
            color: white;
            font-weight: bold;
            font-size: 1rem;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        /* Glitch Animation */
        @keyframes glitch {
            0% { transform: translate(0); }
            20% { transform: translate(-2px, 2px); }
            40% { transform: translate(-2px, -2px); }
            60% { transform: translate(2px, 2px); }
            80% { transform: translate(2px, -2px); }
            100% { transform: translate(0); }
        }

        @media (max-width: 768px) {
            .game-container {
                flex-direction: column;
                align-items: center;
            }
            .sidebar {
                flex-direction: row;
                width: 100%;
                justify-content: center;
                gap: 20px;
                min-width: auto;
            }
            /* Hide desktop instructions, show mobile UI */
            .controls-info { display: none; }
            .mobile-controls { display: flex; }
            
            /* Adjust canvas wrapper margins */
            .canvas-wrapper {
                margin-bottom: 10px;
            }
        }
    </style>
</head>
<body>

    <button class="theme-toggle" id="themeBtn">Cycle Theme</button>

    <header>
        <h1>Wrong Domain</h1>
        <p class="subtitle">System error. Game initialized.</p>
    </header>

    <div class="game-container">
        <div class="canvas-wrapper">
            <canvas id="tetris" width="240" height="400"></canvas>
            <div class="game-over-overlay" id="gameOver">
                <h2>SYSTEM FAILURE</h2>
                <div id="finalScore" style="margin: 10px 0; font-size: 1.2rem; color: var(--accent);">Score: 0</div>
                <button class="btn-restart" onclick="playerReset()">Reboot</button>
            </div>
        </div>

        <div class="sidebar">
            <div class="score-board">
                <div class="label">Buffer</div>
                <div class="score" id="score">0</div>
            </div>
            
            <div class="controls-info">
                <strong>Controls:</strong><br>
                ← → : Move<br>
                ↑ : Rotate<br>
                ↓ : Drop
            </div>
        </div>
    </div>

    <!-- Mobile Controls (D-Pad Style) -->
    <div class="mobile-controls">
        <div class="control-group">
            <div class="m-btn" id="btn-left">←</div>
            <div class="m-btn" id="btn-down">↓</div>
            <div class="m-btn" id="btn-right">→</div>
        </div>
        <div class="control-group">
            <div class="m-btn" id="btn-rotate">↻</div>
        </div>
    </div>

    <script>
        // --- THEME LOGIC ---
        const themes = ['cyberpunk', 'matrix', 'vaporwave'];
        let currentThemeIndex = 0;
        const themeBtn = document.getElementById('themeBtn');
        const body = document.body;

        themeBtn.addEventListener('click', () => {
            currentThemeIndex = (currentThemeIndex + 1) % themes.length;
            const newTheme = themes[currentThemeIndex];
            if(newTheme === 'cyberpunk') {
                body.removeAttribute('data-theme');
            } else {
                body.setAttribute('data-theme', newTheme);
            }
        });

        // --- TETRIS LOGIC ---
        const canvas = document.getElementById('tetris');
        const context = canvas.getContext('2d');
        const scoreElement = document.getElementById('score');
        const gameOverOverlay = document.getElementById('gameOver');
        const finalScoreElement = document.getElementById('finalScore');

        // NOTE: We do NOT set context.scale(20, 20) here anymore.
        // It is set inside the draw loop to be persistent against context loss.

        function arenaSweep() {
            let rowCount = 1;
            outer: for (let y = arena.length - 1; y > 0; --y) {
                for (let x = 0; x < arena[y].length; ++x) {
                    if (arena[y][x] === 0) {
                        continue outer;
                    }
                }
                const row = arena.splice(y, 1)[0].fill(0);
                arena.unshift(row);
                ++y;
                
                player.score += rowCount * 10;
                rowCount *= 2;
            }
        }

        function collide(arena, player) {
            const [m, o] = [player.matrix, player.pos];
            for (let y = 0; y < m.length; ++y) {
                for (let x = 0; x < m[y].length; ++x) {
                    if (m[y][x] !== 0 &&
                        (arena[y + o.y] &&
                        arena[y + o.y][x + o.x]) !== 0) {
                        return true;
                    }
                }
            }
            return false;
        }

        function createMatrix(w, h) {
            const matrix = [];
            while (h--) {
                matrix.push(new Array(w).fill(0));
            }
            return matrix;
        }

        function createPiece(type) {
            if (type === 'I') {
                return [
                    [0, 1, 0, 0],
                    [0, 1, 0, 0],
                    [0, 1, 0, 0],
                    [0, 1, 0, 0],
                ];
            } else if (type === 'L') {
                return [
                    [0, 2, 0],
                    [0, 2, 0],
                    [0, 2, 2],
                ];
            } else if (type === 'J') {
                return [
                    [0, 3, 0],
                    [0, 3, 0],
                    [3, 3, 0],
                ];
            } else if (type === 'O') {
                return [
                    [4, 4],
                    [4, 4],
                ];
            } else if (type === 'Z') {
                return [
                    [5, 5, 0],
                    [0, 5, 5],
                    [0, 0, 0],
                ];
            } else if (type === 'S') {
                return [
                    [0, 6, 6],
                    [6, 6, 0],
                    [0, 0, 0],
                ];
            } else if (type === 'T') {
                return [
                    [0, 7, 0],
                    [7, 7, 7],
                    [0, 0, 0],
                ];
            }
        }

        function drawMatrix(matrix, offset) {
            const colors = [
                null,
                '#FF0D72', // I
                '#0DC2FF', // L
                '#0DFF72', // J
                '#F538FF', // O
                '#FF8E0D', // Z
                '#FFE138', // S
                '#3877FF', // T
            ];

            matrix.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value !== 0) {
                        context.fillStyle = colors[value];
                        context.fillRect(x + offset.x, y + offset.y, 1, 1);
                        
                        context.lineWidth = 0.05;
                        context.strokeStyle = 'rgba(255,255,255,0.5)';
                        context.strokeRect(x + offset.x, y + offset.y, 1, 1);
                    }
                });
            });
        }

        function draw() {
            // FIX: Reset transform first to clear canvas using physical pixels
            // This ensures we always start from a known state (identity matrix)
            context.setTransform(1, 0, 0, 1, 0, 0);
            
            context.fillStyle = '#000';
            context.fillRect(0, 0, canvas.width, canvas.height);

            // FIX: Re-apply scale every frame
            // This fixes the "miniscule game" bug if browser resets context
            context.scale(20, 20);

            drawMatrix(arena, {x: 0, y: 0});
            drawMatrix(player.matrix, player.pos);
        }

        function merge(arena, player) {
            player.matrix.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value !== 0) {
                        arena[y + player.pos.y][x + player.pos.x] = value;
                    }
                });
            });
        }

        function rotate(matrix, dir) {
            for (let y = 0; y < matrix.length; ++y) {
                for (let x = 0; x < y; ++x) {
                    [
                        matrix[x][y],
                        matrix[y][x],
                    ] = [
                        matrix[y][x],
                        matrix[x][y],
                    ];
                }
            }
            if (dir > 0) {
                matrix.forEach(row => row.reverse());
            } else {
                matrix.reverse();
            }
        }

        function playerDrop() {
            player.pos.y++;
            if (collide(arena, player)) {
                player.pos.y--;
                merge(arena, player);
                playerReset();
                arenaSweep();
                updateScore();
            }
            dropCounter = 0;
        }

        function playerMove(dir) {
            player.pos.x += dir;
            if (collide(arena, player)) {
                player.pos.x -= dir;
            }
        }

        function playerReset() {
            const pieces = 'ILJOTSZ';
            player.matrix = createPiece(pieces[pieces.length * Math.random() | 0]);
            player.pos.y = 0;
            player.pos.x = (arena[0].length / 2 | 0) -
                           (player.matrix[0].length / 2 | 0);
            
            // Game Over Check
            if (collide(arena, player)) {
                gameOverOverlay.classList.add('visible');
                finalScoreElement.innerText = "Final Score: " + player.score;
                arena.forEach(row => row.fill(0));
                player.score = 0;
                updateScore();
                isPaused = true;
            } else {
                gameOverOverlay.classList.remove('visible');
                isPaused = false;
                // Ensure we run update loop if it stopped
                if(!animationId) update();
            }
        }

        function playerRotate(dir) {
            const pos = player.pos.x;
            let offset = 1;
            rotate(player.matrix, dir);
            while (collide(arena, player)) {
                player.pos.x += offset;
                offset = -(offset + (offset > 0 ? 1 : -1));
                if (offset > player.matrix[0].length) {
                    rotate(player.matrix, -dir);
                    player.pos.x = pos;
                    return;
                }
            }
        }

        let dropCounter = 0;
        let dropInterval = 1000;
        let lastTime = 0;
        let isPaused = false;
        let animationId = null;

        function update(time = 0) {
            if(!isPaused) {
                const deltaTime = time - lastTime;
                lastTime = time;
                
                // Fix: Cap the delta time to avoid large jumps if the user tabs out and back in
                // If the gap is larger than 1.5 seconds, we assume they were away and ignore that duration
                if (deltaTime < 1500) {
                    dropCounter += deltaTime;
                }
                
                if (dropCounter > dropInterval) {
                    playerDrop();
                }
                draw();
                animationId = requestAnimationFrame(update);
            }
        }

        function updateScore() {
            scoreElement.innerText = player.score;
        }

        const arena = createMatrix(12, 20);
        const player = {
            pos: {x: 0, y: 0},
            matrix: null,
            score: 0,
        };

        // --- CONTROLS ---

        // Keyboard Controls
        document.addEventListener('keydown', event => {
            if (isPaused) return;
            if (event.keyCode === 37) { // Left
                playerMove(-1);
            } else if (event.keyCode === 39) { // Right
                playerMove(1);
            } else if (event.keyCode === 40) { // Down
                playerDrop();
            } else if (event.keyCode === 38) { // Up
                playerRotate(1);
            }
        });

        // Mobile Controls
        // We use addEventListener to allow preventDefault (stops scrolling/zooming)
        function setupMobileBtn(id, action) {
            const btn = document.getElementById(id);
            if(!btn) return;
            
            btn.addEventListener('touchstart', (e) => {
                e.preventDefault(); // Stop scroll/zoom
                if(!isPaused) action();
            }, {passive: false});

            // Prevent default click behavior as well
            btn.addEventListener('click', (e) => e.preventDefault());
        }

        setupMobileBtn('btn-left', () => playerMove(-1));
        setupMobileBtn('btn-right', () => playerMove(1));
        setupMobileBtn('btn-down', () => playerDrop());
        setupMobileBtn('btn-rotate', () => playerRotate(1));

        // Initialize
        playerReset();
        updateScore();
        update();

    </script>
</body>
</html>
